<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15 Algorithm Patterns - Complete Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .stats {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            text-align: center;
        }

        .pattern-card {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-left: 5px solid #4facfe;
            transition: all 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }

        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .pattern-title {
            font-size: 2rem;
            color: #2c3e50;
            font-weight: 700;
        }

        .pattern-number {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 1rem;
        }

        .complexity-badge {
            background: linear-gradient(135deg, #38ef7d 0%, #11998e 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 10px;
        }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-icon {
            font-size: 1.2rem;
        }

        .content-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4facfe;
        }

        .content-box ul {
            margin-left: 20px;
        }

        .content-box li {
            margin-bottom: 8px;
        }

        .code-block {
            background: #f8f9fa;
            color: #2d3748;
            padding: 25px;
            border-radius: 10px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            border: 1px solid #e2e8f0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .table-of-contents {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .table-of-contents h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }

        .toc-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .toc-item {
            padding: 12px 16px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #4facfe;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toc-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .toc-item a {
            text-decoration: none;
            color: #2c3e50;
            font-weight: 600;
        }

        .complexity {
            font-size: 0.85rem;
            color: #6c757d;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .pattern-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .pattern-title {
                font-size: 1.5rem;
            }
            
            .toc-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 15 Algorithm Patterns</h1>
            <p>Master the patterns that solve 90% of coding interview problems</p>
        </div>

        <div class="stats">
            <h2>📚 Complete Study Guide</h2>
            <p>Each pattern includes: How it works, Common variations, When to use it, Key insights, Real-world examples, and Python implementation</p>
        </div>

        <div class="table-of-contents">
            <h2>📋 Table of Contents</h2>
            <div class="toc-grid">
                <div class="toc-item">
                    <a href="#pattern-1">1. Prefix Sum</a>
                    <div class="complexity">O(n) build, O(1) query</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-2">2. Two Pointers</a>
                    <div class="complexity">O(n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-3">3. Sliding Window</a>
                    <div class="complexity">O(n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-4">4. Fast & Slow Pointers</a>
                    <div class="complexity">O(n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-5">5. Linked List Reversal</a>
                    <div class="complexity">O(n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-6">6. Monotonic Stack</a>
                    <div class="complexity">O(n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-7">7. Top K Elements</a>
                    <div class="complexity">O(n log k)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-8">8. Merge Intervals</a>
                    <div class="complexity">O(n log n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-9">9. Modified Binary Search</a>
                    <div class="complexity">O(log n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-10">10. Tree Traversal</a>
                    <div class="complexity">O(n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-11">11. Depth-First Search (DFS)</a>
                    <div class="complexity">O(V + E)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-12">12. Breadth-First Search (BFS)</a>
                    <div class="complexity">O(V + E)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-13">13. Matrix Traversal</a>
                    <div class="complexity">O(m × n)</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-14">14. Backtracking</a>
                    <div class="complexity">O(2^n) typical</div>
                </div>
                <div class="toc-item">
                    <a href="#pattern-15">15. Dynamic Programming</a>
                    <div class="complexity">O(n²) typical</div>
                </div>
            </div>
        </div>

        <!-- Pattern 1: Prefix Sum -->
        <div class="pattern-card" id="pattern-1">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Prefix Sum</div>
                    <div class="complexity-badge">O(n) build, O(1) query</div>
                </div>
                <div class="pattern-number">Pattern #1</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Range queries, cumulative statistics, subarray problems where you need O(1) access to range sums.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Pre-calculate running totals so any range sum becomes a simple subtraction: sum(i to j) = prefix[j+1] - prefix[i]. Think of it like odometer readings - the distance between two points is just the difference in readings.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>1D Prefix Sum:</strong> Basic version for arrays</li>
                        <li><strong>2D Prefix Sum:</strong> For matrix rectangle queries</li>
                        <li><strong>Prefix XOR:</strong> For XOR range queries</li>
                        <li><strong>Prefix with HashMap:</strong> For subarray problems (subarray sum = k)</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: 'sum of subarray', 'range queries', 'cumulative', or multiple queries on the same array.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Transforms multiple O(n) queries into O(1) queries with O(n) preprocessing</li>
                        <li>Essential for competitive programming and data analysis</li>
                        <li>Can be extended to 2D grids for rectangle sum queries</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Financial Systems:</strong> Calculate portfolio performance over date ranges</li>
                        <li><strong>Gaming:</strong> Track player scores across different time periods</li>
                        <li><strong>Analytics:</strong> Sum page views, revenue, or user engagement over time ranges</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def range_sum_queries(nums):
    # Build prefix sum array
    prefix = [0] * (len(nums) + 1)
    for i, num in enumerate(nums):
        prefix[i + 1] = prefix[i] + num
    
    def query(left, right):
        return prefix[right + 1] - prefix[left]
    
    return query

# Usage: O(1) range sum after O(n) preprocessing
query = range_sum_queries([1, 2, 3, 4, 5])
print(query(1, 3))  # Sum from index 1 to 3: 2+3+4 = 9

# Advanced: 2D Prefix Sum
def matrix_2d_prefix_sum(matrix):
    if not matrix or not matrix[0]:
        return None
    
    rows, cols = len(matrix), len(matrix[0])
    prefix = [[0] * (cols + 1) for _ in range(rows + 1)]
    
    for i in range(1, rows + 1):
        for j in range(1, cols + 1):
            prefix[i][j] = (matrix[i-1][j-1] + 
                           prefix[i-1][j] + 
                           prefix[i][j-1] - 
                           prefix[i-1][j-1])
    
    def sum_region(row1, col1, row2, col2):
        return (prefix[row2+1][col2+1] - 
                prefix[row1][col2+1] - 
                prefix[row2+1][col1] + 
                prefix[row1][col1])
    
    return sum_region</pre>
            </div>
        </div>

        <!-- Pattern 2: Two Pointers -->
        <div class="pattern-card" id="pattern-2">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Two Pointers</div>
                    <div class="complexity-badge">O(n)</div>
                </div>
                <div class="pattern-number">Pattern #2</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Sorted arrays, palindromes, partitioning, finding pairs with specific properties.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Use two pointers moving toward each other or in the same direction. Make decisions based on the values at the pointers to eliminate half the search space each step. Like a closing vice or two people walking toward each other.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Opposite Direction:</strong> Start from ends, move toward center (Two Sum)</li>
                        <li><strong>Same Direction:</strong> Both move forward, one faster (Remove Duplicates)</li>
                        <li><strong>Fast/Slow Pattern:</strong> One pointer moves faster than the other</li>
                        <li><strong>Partition Pattern:</strong> One pointer for correct position, one for scanning</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: sorted array, pairs/triplets, palindromes, partitioning, or when brute force would be O(n²).
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Reduces O(n²) brute force to O(n) by using array properties</li>
                        <li>Works when you can make decisions based on pointer comparisons</li>
                        <li>Most powerful when array is sorted or has some ordering</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Data Deduplication:</strong> Remove duplicates from sorted datasets</li>
                        <li><strong>Social Networks:</strong> Find mutual connections between users</li>
                        <li><strong>E-commerce:</strong> Find product pairs within budget constraints</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def two_sum_sorted(nums, target):
    left, right = 0, len(nums) - 1
    
    while left < right:
        current_sum = nums[left] + nums[right]
        if current_sum == target:
            return [left, right]
        elif current_sum < target:
            left += 1  # Need larger sum
        else:
            right -= 1  # Need smaller sum
    
    return []

def three_sum_zero(nums):
    nums.sort()
    result = []
    
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i-1]:
            continue
            
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    
    return result

def is_palindrome(s):
    left, right = 0, len(s) - 1
    
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
            
        if s[left].lower() != s[right].lower():
            return False
            
        left += 1
        right -= 1
    
    return True</pre>
            </div>
        </div>

        <!-- Pattern 3: Sliding Window -->
        <div class="pattern-card" id="pattern-3">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Sliding Window</div>
                    <div class="complexity-badge">O(n)</div>
                </div>
                <div class="pattern-number">Pattern #3</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Contiguous subarray/substring problems, optimization over windows of data.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Maintain a window with left and right pointers. Expand right to include new elements, contract left when window becomes invalid. Like adjusting the width of a telescope's view to keep the target in focus.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Fixed Size Window:</strong> Window size stays constant (max sum of k elements)</li>
                        <li><strong>Variable Size Window:</strong> Window grows/shrinks based on condition (longest substring)</li>
                        <li><strong>Shrinking Window:</strong> Minimize window while maintaining condition</li>
                        <li><strong>Multiple Windows:</strong> Track multiple windows simultaneously</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: contiguous subarray/substring, 'longest/shortest that satisfies...', or optimization over a range.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Avoids recalculating the entire window each time</li>
                        <li>Two variants: Fixed size window and variable size window</li>
                        <li>Perfect for streaming data and real-time analytics</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Network Monitoring:</strong> Track bandwidth usage over time windows</li>
                        <li><strong>Trading:</strong> Moving averages, maximum price in time windows</li>
                        <li><strong>Web Analytics:</strong> Monitor active users in rolling time periods</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def longest_substring_no_repeat(s):
    char_index = {}
    left = 0
    max_length = 0
    
    for right, char in enumerate(s):
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1
        
        char_index[char] = right
        max_length = max(max_length, right - left + 1)
    
    return max_length

def max_sum_subarray_k(nums, k):
    # Fixed window size
    window_sum = sum(nums[:k])
    max_sum = window_sum
    
    for i in range(k, len(nums)):
        window_sum = window_sum - nums[i - k] + nums[i]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

def min_window_substring(s, t):
    from collections import Counter, defaultdict
    
    if not s or not t or len(s) < len(t):
        return ""
    
    required = Counter(t)
    required_chars = len(required)
    
    left = right = 0
    formed = 0
    window_counts = defaultdict(int)
    
    ans = float("inf"), None, None
    
    while right < len(s):
        char = s[right]
        window_counts[char] += 1
        
        if char in required and window_counts[char] == required[char]:
            formed += 1
        
        while left <= right and formed == required_chars:
            char = s[left]
            
            if right - left + 1 < ans[0]:
                ans = (right - left + 1, left, right)
            
            window_counts[char] -= 1
            if char in required and window_counts[char] < required[char]:
                formed -= 1
            
            left += 1
        
        right += 1
    
    return "" if ans[0] == float("inf") else s[ans[1]:ans[2] + 1]</pre>
            </div>
        </div>

        <!-- Pattern 4: Fast & Slow Pointers -->
        <div class="pattern-card" id="pattern-4">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Fast & Slow Pointers</div>
                    <div class="complexity-badge">O(n)</div>
                </div>
                <div class="pattern-number">Pattern #4</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Cycle detection, finding middle elements, pattern detection in sequences.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Two pointers move at different speeds. If there's a cycle, the fast pointer will eventually 'lap' the slow one. Like two runners on a track - if it's circular, the faster runner will catch up.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Floyd's Algorithm:</strong> Fast moves 2x, slow moves 1x for cycle detection</li>
                        <li><strong>Find Middle:</strong> When fast reaches end, slow is at middle</li>
                        <li><strong>Find Cycle Start:</strong> Reset slow to head after detecting cycle</li>
                        <li><strong>K-th from End:</strong> Fast moves k steps ahead first</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: linked lists, cycle detection, finding middle, or need O(1) space instead of O(n) with hash sets.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Leverages different movement speeds to detect patterns</li>
                        <li>Space-efficient: O(1) space vs O(n) for hash set approach</li>
                        <li>Mathematical proof based on race track principle</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>System Architecture:</strong> Detect infinite loops in distributed systems</li>
                        <li><strong>Data Validation:</strong> Check for circular references in data structures</li>
                        <li><strong>Blockchain:</strong> Detect cycles in transaction graphs</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def has_cycle(head):
    if not head or not head.next:
        return False
    
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            return True
    
    return False

def find_middle_node(head):
    if not head:
        return None
    
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow

def find_cycle_start(head):
    if not head or not head.next:
        return None
    
    # Phase 1: Detect cycle
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return None  # No cycle
    
    # Phase 2: Find start of cycle
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow

def is_happy_number(n):
    def get_next(num):
        total = 0
        while num > 0:
            digit = num % 10
            total += digit * digit
            num //= 10
        return total
    
    slow = fast = n
    
    while True:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
        
        if fast == 1:
            return True
        if slow == fast:
            return False</pre>
            </div>
        </div>

        <!-- Pattern 5: Linked List Reversal -->
        <div class="pattern-card" id="pattern-5">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Linked List Reversal</div>
                    <div class="complexity-badge">O(n)</div>
                </div>
                <div class="pattern-number">Pattern #5</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Reversing portions of linked lists, palindrome checking, list manipulation.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Use three pointers: previous, current, and next. Break the link from current to next, redirect it to previous, then move all pointers forward. Like reversing a chain link by link.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Reverse Entire List:</strong> Standard three-pointer technique</li>
                        <li><strong>Reverse Between Positions:</strong> Reverse only a segment</li>
                        <li><strong>Reverse in K Groups:</strong> Reverse every k nodes</li>
                        <li><strong>Swap Pairs:</strong> Special case of k=2 reversal</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: reverse linked list, palindrome checking, reordering nodes, or manipulating list structure.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Master the three-pointer technique: prev, current, next</li>
                        <li>Can reverse entire list or specific portions</li>
                        <li>Essential for many list manipulation problems</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Undo Systems:</strong> Reverse operations in text editors</li>
                        <li><strong>Network Routing:</strong> Reverse path discovery in networking</li>
                        <li><strong>Database Transactions:</strong> Rollback sequences</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def reverse_linked_list(head):
    prev = None
    current = head
    
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
    
    return prev

def reverse_between(head, left, right):
    if not head or left == right:
        return head
    
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    
    # Move to position before left
    for _ in range(left - 1):
        prev = prev.next
    
    # Reverse the sublist
    current = prev.next
    for _ in range(right - left):
        next_temp = current.next
        current.next = next_temp.next
        next_temp.next = prev.next
        prev.next = next_temp
    
    return dummy.next

def reverse_k_group(head, k):
    def get_length(node):
        length = 0
        while node:
            length += 1
            node = node.next
        return length
    
    def reverse_group(start, k):
        prev = None
        current = start
        
        for _ in range(k):
            next_temp = current.next
            current.next = prev
            prev = current
            current = next_temp
        
        return prev, current
    
    length = get_length(head)
    if length < k:
        return head
    
    dummy = ListNode(0)
    dummy.next = head
    prev_group = dummy
    
    while length >= k:
        group_start = prev_group.next
        new_head, next_start = reverse_group(group_start, k)
        
        prev_group.next = new_head
        group_start.next = next_start
        prev_group = group_start
        
        length -= k
    
    return dummy.next</pre>
            </div>
        </div>

        <!-- Pattern 8: Merge Intervals -->
        <div class="pattern-card" id="pattern-8">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Merge Intervals</div>
                    <div class="complexity-badge">O(n log n)</div>
                </div>
                <div class="pattern-number">Pattern #8</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Overlapping time periods, calendar scheduling, range consolidation.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Sort intervals by start time, then iterate through checking if current interval overlaps with the previous (current.start <= previous.end). Merge overlapping intervals into one.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Merge Overlapping:</strong> Combine intervals that overlap</li>
                        <li><strong>Insert Interval:</strong> Add new interval and merge with existing ones</li>
                        <li><strong>Meeting Rooms:</strong> Check if person can attend all meetings (no overlaps)</li>
                        <li><strong>Minimum Meeting Rooms:</strong> Count maximum overlapping intervals at any time</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: time intervals, scheduling, calendar problems, overlapping ranges, or resource allocation.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Sort by start time first</li>
                        <li>Merge condition: current.start <= previous.end</li>
                        <li>Essential for time-based scheduling systems</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Calendar Apps:</strong> Meeting conflict detection, free time slots</li>
                        <li><strong>Resource Management:</strong> Server allocation, room booking</li>
                        <li><strong>Data Processing:</strong> Time series data consolidation</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def merge_intervals(intervals):
    if not intervals:
        return []
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        
        if current[0] <= last[1]:
            merged[-1] = [last[0], max(last[1], current[1])]
        else:
            merged.append(current)
    
    return merged

def min_meeting_rooms(intervals):
    if not intervals:
        return 0
    
    starts = sorted([interval[0] for interval in intervals])
    ends = sorted([interval[1] for interval in intervals])
    
    start_ptr = end_ptr = 0
    rooms_needed = max_rooms = 0
    
    while start_ptr < len(starts):
        if starts[start_ptr] < ends[end_ptr]:
            rooms_needed += 1
            start_ptr += 1
        else:
            rooms_needed -= 1
            end_ptr += 1
        
        max_rooms = max(max_rooms, rooms_needed)
    
    return max_rooms

def insert_interval(intervals, new_interval):
    result = []
    i = 0
    
    # Add all intervals that end before new_interval starts
    while i < len(intervals) and intervals[i][1] < new_interval[0]:
        result.append(intervals[i])
        i += 1
    
    # Merge overlapping intervals with new_interval
    while i < len(intervals) and intervals[i][0] <= new_interval[1]:
        new_interval[0] = min(new_interval[0], intervals[i][0])
        new_interval[1] = max(new_interval[1], intervals[i][1])
        i += 1
    
    result.append(new_interval)
    result.extend(intervals[i:])
    
    return result</pre>
            </div>
        </div>

        <!-- Pattern 9: Modified Binary Search -->
        <div class="pattern-card" id="pattern-9">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Modified Binary Search</div>
                    <div class="complexity-badge">O(log n)</div>
                </div>
                <div class="pattern-number">Pattern #9</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Searching in rotated/modified sorted arrays, finding peak elements, search spaces.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Traditional binary search but adapt the condition for which half to search. Key insight: even in rotated arrays, one half is always normally sorted. Identify the sorted half and decide accordingly.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Rotated Sorted Array:</strong> Find which half is sorted, then search accordingly</li>
                        <li><strong>Find Peak Element:</strong> Compare mid with neighbors to decide direction</li>
                        <li><strong>Find Minimum in Rotated:</strong> Compare mid with right boundary</li>
                        <li><strong>Search Range:</strong> Find first and last occurrence using modified binary search</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: rotated arrays, peak finding, searching in modified sorted data, or O(log n) time requirement.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Adapt binary search to non-standard sorted arrays</li>
                        <li>Key is identifying which half maintains sorted property</li>
                        <li>Essential for O(log n) solutions in modified search spaces</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Database Systems:</strong> Index searching with modifications</li>
                        <li><strong>System Monitoring:</strong> Finding peaks in cyclic data</li>
                        <li><strong>Game Development:</strong> Searching in circular game worlds</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def search_rotated_array(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        if nums[left] <= nums[mid]:  # Left half sorted
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # Right half sorted
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1

def find_peak_element(nums):
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1
    
    return left

def find_minimum_rotated(nums):
    left, right = 0, len(nums) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    
    return nums[left]

def search_range(nums, target):
    def find_bound(is_first):
        left, right = 0, len(nums) - 1
        result = -1
        
        while left <= right:
            mid = (left + right) // 2
            
            if nums[mid] == target:
                result = mid
                if is_first:
                    right = mid - 1
                else:
                    left = mid + 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return result
    
    first = find_bound(True)
    last = find_bound(False)
    
    return [first, last]</pre>
            </div>
        </div>

        <!-- Pattern 10: Tree Traversal -->
        <div class="pattern-card" id="pattern-10">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Tree Traversal</div>
                    <div class="complexity-badge">O(n)</div>
                </div>
                <div class="pattern-number">Pattern #10</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Processing tree nodes, path problems, tree construction and validation.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Visit nodes in specific order: Inorder (Left-Root-Right), Preorder (Root-Left-Right), Postorder (Left-Right-Root). Use recursion or stack to maintain the order and current position.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Inorder:</strong> Left-Root-Right (gives sorted order for BST)</li>
                        <li><strong>Preorder:</strong> Root-Left-Right (good for copying tree structure)</li>
                        <li><strong>Postorder:</strong> Left-Right-Root (good for deleting nodes)</li>
                        <li><strong>Level Order:</strong> BFS traversal, process level by level</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: binary trees, tree validation, path problems, or need to process nodes in specific order.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Three main types: preorder, inorder, postorder</li>
                        <li>Recursive vs iterative implementations</li>
                        <li>Essential for all tree-related problems</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>File Systems:</strong> Directory traversal, file indexing</li>
                        <li><strong>Compilers:</strong> Abstract syntax tree processing</li>
                        <li><strong>Organizational Charts:</strong> Hierarchy analysis</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def inorder_traversal(root):
    result = []
    stack = []
    current = root
    
    while stack or current:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        result.append(current.val)
        current = current.right
    
    return result

def preorder_traversal(root):
    if not root:
        return []
    
    result = []
    stack = [root]
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result

def level_order_traversal(root):
    if not root:
        return []
    
    from collections import deque
    result = []
    queue = deque([root])
    
    while queue:
        level_size = len(queue)
        level_nodes = []
        
        for _ in range(level_size):
            node = queue.popleft()
            level_nodes.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(level_nodes)
    
    return result

def validate_bst(root):
    def validate(node, min_val, max_val):
        if not node:
            return True
        
        if node.val <= min_val or node.val >= max_val:
            return False
        
        return (validate(node.left, min_val, node.val) and 
                validate(node.right, node.val, max_val))
    
    return validate(root, float('-inf'), float('inf'))</pre>
            </div>
        </div>

        <!-- Pattern 11: Depth-First Search (DFS) -->
        <div class="pattern-card" id="pattern-11">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Depth-First Search (DFS)</div>
                    <div class="complexity-badge">O(V + E)</div>
                </div>
                <div class="pattern-number">Pattern #11</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Graph traversal, path finding, connected components, backtracking problems.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Explore as deep as possible down one path before backtracking. Use recursion (implicit stack) or explicit stack. Mark visited nodes to avoid cycles. Like exploring a maze by always going deeper until you hit a dead end.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Recursive DFS:</strong> Use function call stack (clean but risk stack overflow)</li>
                        <li><strong>Iterative DFS:</strong> Use explicit stack (more memory control)</li>
                        <li><strong>Path Finding:</strong> Track path while exploring</li>
                        <li><strong>Connected Components:</strong> DFS from each unvisited node</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: graphs, islands, connected components, paths in trees/graphs, or backtracking problems.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Explores as far as possible before backtracking</li>
                        <li>Uses stack (recursion or explicit)</li>
                        <li>Perfect for finding paths and connected components</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Social Networks:</strong> Finding connected user groups</li>
                        <li><strong>Game AI:</strong> Maze solving, pathfinding</li>
                        <li><strong>Web Crawling:</strong> Website structure analysis</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def count_islands(grid):
    if not grid or not grid[0]:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    visited = set()
    islands = 0
    
    def dfs(r, c):
        if (r < 0 or r >= rows or c < 0 or c >= cols or 
            (r, c) in visited or grid[r][c] == '0'):
            return
        
        visited.add((r, c))
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        for dr, dc in directions:
            dfs(r + dr, c + dc)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1' and (r, c) not in visited:
                dfs(r, c)
                islands += 1
    
    return islands

def has_path(graph, start, end):
    visited = set()
    
    def dfs(node):
        if node in visited:
            return False
        
        visited.add(node)
        
        for neighbor in graph[node]:
            if neighbor == end or dfs(neighbor):
                return True
        
        return False
    
    return start == end or dfs(start)

def clone_graph(node):
    if not node:
        return None
    
    cloned = {}
    
    def dfs(original):
        if original in cloned:
            return cloned[original]
        
        clone = Node(original.val)
        cloned[original] = clone
        
        for neighbor in original.neighbors:
            clone.neighbors.append(dfs(neighbor))
        
        return clone
    
    return dfs(node)</pre>
            </div>
        </div>

        <!-- Pattern 12: Breadth-First Search (BFS) -->
        <div class="pattern-card" id="pattern-12">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Breadth-First Search (BFS)</div>
                    <div class="complexity-badge">O(V + E)</div>
                </div>
                <div class="pattern-number">Pattern #12</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Shortest path problems, level-by-level processing, minimum steps to reach target.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Explore all nodes at current distance before moving to next distance. Use queue to maintain order. Guarantees shortest path in unweighted graphs because you explore by layers/levels.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Standard BFS:</strong> Use queue, process level by level</li>
                        <li><strong>Multi-source BFS:</strong> Start BFS from multiple points simultaneously</li>
                        <li><strong>Bidirectional BFS:</strong> Start from both source and target, meet in middle</li>
                        <li><strong>Level Order:</strong> Track levels separately for tree problems</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: shortest path, minimum steps, level-by-level processing, or 'minimum time/distance' in unweighted scenarios.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Explores neighbors before going deeper</li>
                        <li>Guarantees shortest path in unweighted graphs</li>
                        <li>Uses queue for implementation</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>GPS Navigation:</strong> Shortest route finding</li>
                        <li><strong>Social Networks:</strong> Degrees of separation</li>
                        <li><strong>Game Development:</strong> Turn-based movement, spell effects</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">from collections import deque

def shortest_path_length(graph, start, end):
    if start == end:
        return 0
    
    queue = deque([(start, 0)])
    visited = {start}
    
    while queue:
        node, distance = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor == end:
                return distance + 1
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, distance + 1))
    
    return -1

def rotting_oranges(grid):
    if not grid:
        return -1
    
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c, 0))
            elif grid[r][c] == 1:
                fresh_count += 1
    
    if fresh_count == 0:
        return 0
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    max_time = 0
    
    while queue:
        r, c, time = queue.popleft()
        max_time = max(max_time, time)
        
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            
            if (0 <= nr < rows and 0 <= nc < cols and 
                grid[nr][nc] == 1):
                
                grid[nr][nc] = 2
                fresh_count -= 1
                queue.append((nr, nc, time + 1))
    
    return max_time if fresh_count == 0 else -1

def word_ladder_length(begin_word, end_word, word_list):
    if end_word not in word_list:
        return 0
    
    word_set = set(word_list)
    queue = deque([(begin_word, 1)])
    
    while queue:
        word, length = queue.popleft()
        
        if word == end_word:
            return length
        
        for i in range(len(word)):
            for c in 'abcdefghijklmnopqrstuvwxyz':
                new_word = word[:i] + c + word[i+1:]
                
                if new_word in word_set:
                    word_set.remove(new_word)
                    queue.append((new_word, length + 1))
    
    return 0</pre>
            </div>
        </div>

        <!-- Pattern 13: Matrix Traversal -->
        <div class="pattern-card" id="pattern-13">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Matrix Traversal</div>
                    <div class="complexity-badge">O(m × n)</div>
                </div>
                <div class="pattern-number">Pattern #13</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    2D grid problems, pathfinding, flood fill, region processing.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Navigate through 2D grid using coordinate arithmetic. Common patterns: 4-directional (up/down/left/right) or 8-directional movement. Handle boundaries carefully and track visited cells.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>4-Directional:</strong> Move up/down/left/right only</li>
                        <li><strong>8-Directional:</strong> Include diagonal movements</li>
                        <li><strong>Spiral Traversal:</strong> Move in spiral pattern (right→down→left→up)</li>
                        <li><strong>Flood Fill:</strong> DFS/BFS to fill connected regions</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: 2D grids, matrices, islands, regions, image processing, or coordinate-based problems.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Common directions: 4-directional and 8-directional movement</li>
                        <li>Often combined with DFS/BFS</li>
                        <li>Handle boundary conditions carefully</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Image Processing:</strong> Flood fill, edge detection</li>
                        <li><strong>Game Development:</strong> Tile-based games, pathfinding</li>
                        <li><strong>Geographic Systems:</strong> Region analysis, map processing</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def spiral_order(matrix):
    if not matrix or not matrix[0]:
        return []
    
    result = []
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1
    
    while top <= bottom and left <= right:
        # Traverse right
        for col in range(left, right + 1):
            result.append(matrix[top][col])
        top += 1
        
        # Traverse down
        for row in range(top, bottom + 1):
            result.append(matrix[row][right])
        right -= 1
        
        # Traverse left
        if top <= bottom:
            for col in range(right, left - 1, -1):
                result.append(matrix[bottom][col])
            bottom -= 1
        
        # Traverse up
        if left <= right:
            for row in range(bottom, top - 1, -1):
                result.append(matrix[row][left])
            left += 1
    
    return result

def flood_fill(image, sr, sc, new_color):
    if not image or image[sr][sc] == new_color:
        return image
    
    original_color = image[sr][sc]
    rows, cols = len(image), len(image[0])
    
    def dfs(r, c):
        if (r < 0 or r >= rows or c < 0 or c >= cols or 
            image[r][c] != original_color):
            return
        
        image[r][c] = new_color
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        for dr, dc in directions:
            dfs(r + dr, c + dc)
    
    dfs(sr, sc)
    return image

def rotate_matrix_90(matrix):
    n = len(matrix)
    
    # Transpose matrix
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    
    # Reverse each row
    for i in range(n):
        matrix[i].reverse()

def set_matrix_zeros(matrix):
    if not matrix:
        return
    
    rows, cols = len(matrix), len(matrix[0])
    first_row_zero = any(matrix[0][j] == 0 for j in range(cols))
    first_col_zero = any(matrix[i][0] == 0 for i in range(rows))
    
    # Use first row and column as markers
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][j] == 0:
                matrix[i][0] = 0
                matrix[0][j] = 0
    
    # Set zeros based on markers
    for i in range(1, rows):
        for j in range(1, cols):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0
    
    # Handle first row and column
    if first_row_zero:
        for j in range(cols):
            matrix[0][j] = 0
    
    if first_col_zero:
        for i in range(rows):
            matrix[i][0] = 0</pre>
            </div>
        </div>

        <!-- Pattern 14: Backtracking -->
        <div class="pattern-card" id="pattern-14">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Backtracking</div>
                    <div class="complexity-badge">O(2^n) typical</div>
                </div>
                <div class="pattern-number">Pattern #14</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Generating combinations, permutations, solving constraint satisfaction problems.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Build solution incrementally by making choices, then undo (backtrack) if choice leads to invalid solution. Like solving a maze by trying each path and backing up when you hit a dead end.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Generate All:</strong> Find all valid combinations/permutations</li>
                        <li><strong>Find One:</strong> Stop at first valid solution</li>
                        <li><strong>Constraint Satisfaction:</strong> Add constraints to prune invalid paths early</li>
                        <li><strong>Optimization:</strong> Track best solution found so far</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: generate all combinations/permutations, solve puzzles (Sudoku, N-Queens), or explore all possible solutions.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Systematic exploration with rollback capability</li>
                        <li>Build solution incrementally and undo choices</li>
                        <li>Essential for problems requiring exhaustive search</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Puzzle Solving:</strong> Sudoku, N-Queens, crossword puzzles</li>
                        <li><strong>Game AI:</strong> Chess move generation, game tree search</li>
                        <li><strong>Configuration:</strong> Finding valid system configurations</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def generate_parentheses(n):
    result = []
    
    def backtrack(current, open_count, close_count):
        if len(current) == 2 * n:
            result.append(current)
            return
        
        if open_count < n:
            backtrack(current + '(', open_count + 1, close_count)
        
        if close_count < open_count:
            backtrack(current + ')', open_count, close_count + 1)
    
    backtrack('', 0, 0)
    return result

def permutations(nums):
    result = []
    
    def backtrack(current_perm):
        if len(current_perm) == len(nums):
            result.append(current_perm[:])
            return
        
        for num in nums:
            if num not in current_perm:
                current_perm.append(num)
                backtrack(current_perm)
                current_perm.pop()
    
    backtrack([])
    return result

def combinations(n, k):
    result = []
    
    def backtrack(start, current_combo):
        if len(current_combo) == k:
            result.append(current_combo[:])
            return
        
        for i in range(start, n + 1):
            current_combo.append(i)
            backtrack(i + 1, current_combo)
            current_combo.pop()
    
    backtrack(1, [])
    return result

def solve_n_queens(n):
    result = []
    board = [['.' for _ in range(n)] for _ in range(n)]
    
    def is_safe(row, col):
        # Check column
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        
        # Check diagonals
        i, j = row - 1, col - 1
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        
        i, j = row - 1, col + 1
        while i >= 0 and j < n:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j += 1
        
        return True
    
    def backtrack(row):
        if row == n:
            result.append([''.join(row) for row in board])
            return
        
        for col in range(n):
            if is_safe(row, col):
                board[row][col] = 'Q'
                backtrack(row + 1)
                board[row][col] = '.'
    
    backtrack(0)
    return result</pre>
            </div>
        </div>

        <!-- Pattern 15: Dynamic Programming -->
        <div class="pattern-card" id="pattern-15">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Dynamic Programming</div>
                    <div class="complexity-badge">O(n²) typical</div>
                </div>
                <div class="pattern-number">Pattern #15</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Optimization problems with overlapping subproblems and optimal substructure.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Break problem into smaller subproblems, solve each once, and store results. Future problems reuse stored answers. Either top-down (memoization) or bottom-up (tabulation). Like having a cheat sheet for test questions you've already solved.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Top-down (Memoization):</strong> Recursive with cache to store results</li>
                        <li><strong>Bottom-up (Tabulation):</strong> Iterative, fill table from base cases up</li>
                        <li><strong>Space Optimization:</strong> Use O(1) or O(n) space instead of O(n²)</li>
                        <li><strong>State Machine DP:</strong> States represent different conditions/modes</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: optimization (min/max), counting ways, decision problems, or exponential brute force that can be memoized.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💡</span>Key Insights</h3>
                <div class="content-box">
                    <ul>
                        <li>Memoization (top-down) vs tabulation (bottom-up)</li>
                        <li>Identify state transitions and recurrence relations</li>
                        <li>Often transforms exponential solutions to polynomial</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🌍</span>Real-World Examples</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Finance:</strong> Portfolio optimization, option pricing</li>
                        <li><strong>Bioinformatics:</strong> DNA sequence alignment, protein folding</li>
                        <li><strong>Operations Research:</strong> Resource allocation, scheduling</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1

def longest_increasing_subsequence(nums):
    if not nums:
        return 0
    
    n = len(nums)
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)

def edit_distance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(
                    dp[i-1][j],      # Delete
                    dp[i][j-1],      # Insert
                    dp[i-1][j-1]     # Replace
                )
    
    return dp[m][n]

def maximum_subarray_sum(nums):
    if not nums:
        return 0
    
    max_ending_here = max_so_far = nums[0]
    
    for i in range(1, len(nums)):
        max_ending_here = max(nums[i], max_ending_here + nums[i])
        max_so_far = max(max_so_far, max_ending_here)
    
    return max_so_far

def house_robber(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    prev2 = nums[0]
    prev1 = max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        current = max(prev1, prev2 + nums[i])
        prev2, prev1 = prev1, current
    
    return prev1</pre>
            </div>
        </div>
        <div class="pattern-card" id="pattern-6">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Monotonic Stack</div>
                    <div class="complexity-badge">O(n)</div>
                </div>
                <div class="pattern-number">Pattern #6</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Next/previous greater/smaller element problems, histogram areas, temperature spans.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Maintain a stack that keeps elements in increasing or decreasing order. When a new element breaks the order, pop elements until order is restored. Each popped element found its 'next greater/smaller'.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>Next Greater Element:</strong> Decreasing stack, pop when current > stack.top</li>
                        <li><strong>Next Smaller Element:</strong> Increasing stack, pop when current < stack.top</li>
                        <li><strong>Previous Greater/Smaller:</strong> Same logic but process from left to right</li>
                        <li><strong>Circular Array:</strong> Process array twice to handle wraparound</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: 'next greater/smaller', histogram problems, temperature spans, or removing elements to form sequence.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">def next_greater_element(nums):
    stack = []
    result = [-1] * len(nums)
    
    for i, num in enumerate(nums):
        while stack and nums[stack[-1]] < num:
            index = stack.pop()
            result[index] = num
        stack.append(i)
    
    return result

def daily_temperatures(temps):
    stack = []
    result = [0] * len(temps)
    
    for i, temp in enumerate(temps):
        while stack and temps[stack[-1]] < temp:
            prev_index = stack.pop()
            result[prev_index] = i - prev_index
        stack.append(i)
    
    return result

def largest_rectangle_histogram(heights):
    stack = []
    max_area = 0
    
    for i, height in enumerate(heights):
        while stack and heights[stack[-1]] > height:
            h = heights[stack.pop()]
            w = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * w)
        stack.append(i)
    
    while stack:
        h = heights[stack.pop()]
        w = len(heights) if not stack else len(heights) - stack[-1] - 1
        max_area = max(max_area, h * w)
    
    return max_area</pre>
            </div>
        </div>

        <!-- Pattern 7: Top K Elements -->
        <div class="pattern-card" id="pattern-7">
            <div class="pattern-header">
                <div>
                    <div class="pattern-title">Top K Elements</div>
                    <div class="complexity-badge">O(n log k)</div>
                </div>
                <div class="pattern-number">Pattern #7</div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">🎯</span>Best Use Case</h3>
                <div class="content-box">
                    Finding K largest/smallest/most frequent elements efficiently.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🧠</span>How It Works</h3>
                <div class="content-box">
                    Use a heap of size K. For K largest, use min-heap (root is smallest of the K largest). When heap size exceeds K, remove the root. Like keeping only the 'elite' members of a club.
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🔄</span>Common Variations</h3>
                <div class="content-box">
                    <ul>
                        <li><strong>K Largest:</strong> Min-heap of size K, remove small elements</li>
                        <li><strong>K Smallest:</strong> Max-heap of size K, remove large elements</li>
                        <li><strong>K Most Frequent:</strong> Count frequencies, then use heap</li>
                        <li><strong>Kth Largest in Stream:</strong> Dynamic heap that maintains Kth largest</li>
                    </ul>
                </div>
            </div>

            <div class="section">
                <h3><span class="section-icon">🚨</span>When to Use This Pattern</h3>
                <div class="content-box">
                    When you see: 'K largest/smallest', 'top K', 'most frequent', or when you need partial sorting without full O(n log n) cost.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="section-icon">💻</span>Python Implementation</h3>
                <pre class="code-block">import heapq
from collections import Counter

def k_largest_elements(nums, k):
    if k >= len(nums):
        return nums
    
    heap = nums[:k]
    heapq.heapify(heap)
    
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heapreplace(heap, num)
    
    return sorted(heap, reverse=True)

def top_k_frequent(nums, k):
    counter = Counter(nums)
    heap = [(-freq, num) for num, freq in counter.items()]
    heapq.heapify(heap)
    
    result = []
    for _ in range(k):
        freq, num = heapq.heappop(heap)
        result.append(num)
    
    return result

def k_closest_points(points, k):
    heap = []
    
    for x, y in points:
        distance = x*x + y*y
        
        if len(heap) < k:
            heapq.heappush(heap, (-distance, x, y))
        elif distance < -heap[0][0]:
            heapq.heapreplace(heap, (-distance, x, y))
    
    return [(x, y) for _, x, y in heap]</pre>
            </div>
        </div>

        <!-- Continue with remaining patterns 8-15... -->
        <!-- Adding a final summary section -->
        
        <div class="stats">
            <h2>🎯 Pattern Recognition Quick Reference</h2>
            <div style="text-align: left; max-width: 800px; margin: 0 auto;">
                <p><strong>Array/String + Two elements</strong> → Two Pointers</p>
                <p><strong>Contiguous subarray/substring</strong> → Sliding Window</p>
                <p><strong>Cycle detection</strong> → Fast & Slow Pointers</p>
                <p><strong>Tree/Graph traversal</strong> → DFS/BFS</p>
                <p><strong>Optimization with choices</strong> → Dynamic Programming</p>
                <p><strong>Generate all combinations</strong> → Backtracking</p>
                <p><strong>Range queries</strong> → Prefix Sum</p>
                <p><strong>K largest/smallest</strong> → Heap (Top K)</p>
                <p><strong>Intervals</strong> → Merge/Sort by start time</p>
                <p><strong>Next greater/smaller</strong> → Monotonic Stack</p>
            </div>
        </div>
    </div>

    <script>
        function scrollToPattern(patternId) {
            const element = document.getElementById(patternId);
            if (element) {
                element.scrollIntoView({ 
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        }
    </script>
</body>
</html>